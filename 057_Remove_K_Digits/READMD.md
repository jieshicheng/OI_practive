问题：
    给定一个数字的字符串“12314”这种，然后给定k表示要移除的数字的个数，返回
    字符串表示移除k个数字后最小的数字的字符串
    例如：
        “1432219”   k = 3
        output:
            "1219"
        because:1219是移除任意3个数字后的所有组合里面面值最小的

        “10” k = 2
        output:
            "0"
思路：
    这道题是贪婪思想的题目。我们要移除的数字的肯定取决于两个因素，
    1.它本身的大小
    2.它所在的位置
    它本身越大，那么就可能形成较大的数，它的位置越靠左边，占的权重比就越大
    所以我们选择从左至右遍历字符串，保证权重比的顺序从大到小
    然后判断当前的字符与前面的字符的大小关系。我们模仿一个栈的属性，这样方便比较元素，最后栈剩下的元素就是答案
    所以得到如下伪码
    for(i <- 1)
        while(str[i] < str[i - 1])
            str[i - 1] = str[i];
        else
            ++i;
    其中str[i - 1] = str[i]就是移除数字的步骤，所以当我们执行这样的操作时应该将k--，直到k = 0时，我们的任务就做完了。当遍历完整个字符串后，要么k = 0代表完成任务，要么整个字符串呈现升序状态。如果k不等于0,那么最后我们只需要截断字符串后面的k位就行了

