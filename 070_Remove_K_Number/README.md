蓝桥杯第八届C++B组国赛题目第五题
    题目：给定一个数组序列，再给定一个值k，序列中某一个数如果它加k或者减k的数也在这个数组里面，那么他们就是互斥的，不行。
        比如序列1,2,4,-1   k = 2，这个序列存在互斥，不行，所以要删除一些元素。1，与-1不能同时存在，2与4也是同理。
        现在给定序列，要你求这个序列满足条件下其中最多能有多少个元素。对于给定例子，解为2

    思路：
        一开始看用暴力的想法去分析。发现复杂度是树形的。对于互斥的元素，删除它本身与删除与他互斥的元素都会影响到后面的元素是否也互斥
        所以要树形递归下去分别求解。这使得复杂度很高。直到复杂度的原因所在了那也方便优化了。因为重复计算太多东西了，所以我们用dp来做
        现在寻找递推公式，我们假设
            dp[i] = 前i个元素组成的序列能拥有的最优解
            那么对于i + 1，如果i + 1这个元素与前面的所有元素都不冲突，那么dp[i + 1] = dp[i] + 1
            如果对于i + 1这个元素与前i个中有冲突，假设只与第k个元素冲突（0<k<i）那么
                dp[i + 1] = max((dp[i] - dp[k]) + (dp[k - 1] - dp[0]) + 1, dp[i])

                其中dp[i]-dp[k]为k后面的一段。dp[k - 1]-dp[0]为k前面的一段。意味将k这个点删除后这个序列还剩下的最大元素个数
                然后最后+1意味加上第i+1这个元素。
                如果整个0-i序列中有k1,k2两个点，那么就有三个区间段相加，依次类推。
                为什么这样子就能保证最优解了呢？
                因为我们在决策第i+1个元素时，如果没有冲突，那么就是前面一整段的值+1,如果有冲突，那么我们要考虑两种情况
                1.放弃当前这个i + 1
                2.放弃前面与i+1冲突的所有元素

                对于第一种情况，那么就是dp[i]
                对于第二中情况，我们要将前面的元素都删除，然而删除一个元素不能简单的dp[i] - 1，因为你不确定这个元素是否在dp[i]中
                所以我们用dp[i] - dp[k] + dp[k - 1] - dp[0]来表示整个序列去掉k之后的真正解。
